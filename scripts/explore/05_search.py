"""
05_search.py
?€?¥ë�œ ?„ë² ?©ì—�??ì¿¼ë¦¬ ë¬¸ìž¥ê³??˜ë??�ìœ¼ë¡?ê°€??? ì‚¬??ë¬¸ìž¥??ì°¾ìŠµ?ˆë‹¤.

?¤í–‰ ?ˆì‹œ:
  uv run python scripts/explore/05_search.py query="ì£½ê³  ?¶ì? ?Šì•„"
  uv run python scripts/explore/05_search.py query="ì£½ê³  ?¶ì? ?Šì•„" search.topk=20
  uv run python scripts/explore/05_search.py query="ì£½ê³  ?¶ì? ?Šì•„" search.topk=10 model=sroberta

ì¶œë ¥:
  - ì½”ì‚¬??? ì‚¬??ê¸°ì? ?�ìœ„ Kê°?ë¬¸ìž¥ + ì¹´í…Œê³ ë¦¬
  - ì¹´í…Œê³ ë¦¬ë³?ë¶„í�¬ ?”ì•½
"""

from __future__ import annotations

import json
from pathlib import Path

import hydra
import numpy as np
from hydra.utils import instantiate
from omegaconf import DictConfig, OmegaConf


def load_jsonl(path: Path) -> list[dict]:
    with path.open(encoding="utf-8") as f:
        return [json.loads(line) for line in f if line.strip()]


def cosine_similarity(query_vec: np.ndarray, corpus: np.ndarray) -> np.ndarray:
    """L2-?•ê·œ?”ë�œ ë²¡í„° ê°€?????´ì � = ì½”ì‚¬??? ì‚¬??"""
    q = query_vec / (np.linalg.norm(query_vec) + 1e-9)
    # corpusê°€ ?´ë? ?•ê·œ?”ë�¼ ?ˆìœ¼ë©??´ì �ë§Œìœ¼ë¡?ì¶©ë¶„
    return corpus @ q  # (N,)


@hydra.main(version_base=None, config_path="../configs", config_name="config")
def main(cfg: DictConfig) -> None:
    # ?€?€ ?¤ì • ?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€
    search_cfg = cfg.get("search", OmegaConf.create({}))
    query: str = search_cfg.get("query", "")
    topk: int   = search_cfg.get("topk", 10)

    if not query:
        raise ValueError(
            "ì¿¼ë¦¬ ë¬¸ìž¥???…ë ¥?˜ì„¸??\n"
            "  ?? uv run python scripts/explore/05_search.py search.query=\"ì£½ê³  ?¶ì? ?Šì•„\""
        )

    model_name: str = cfg.model.get("name", "model")
    artifacts_dir = Path(cfg.data.artifacts_dir)
    emb_path  = artifacts_dir / "embeddings" / model_name / "embeddings.npy"
    meta_path = artifacts_dir / "embeddings" / model_name / "metadata.jsonl"

    if not emb_path.exists():
        raise FileNotFoundError(f"?„ë² ???†ì�Œ: {emb_path}\në¨¼ì? 01_embed.py ?¤í–‰")

    # ?€?€ ì½”í�¼??ë¡œë“œ ?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€
    print(f"\n[ë¡œë“œ] {emb_path}")
    corpus = np.load(emb_path)               # (N, D) float32
    rows   = load_jsonl(meta_path)
    texts  = [r["text"]  for r in rows]
    labels = [r["label"] for r in rows]
    print(f"  ì½”í�¼?? {len(texts):,}ê°?ë¬¸ìž¥ (dim={corpus.shape[1]})")

    # ?€?€ ì¿¼ë¦¬ ?¸ì½”???€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€
    print(f"\n[ì¿¼ë¦¬] \"{query}\"")
    print(f"[ëª¨ë�¸] {model_name} ë¡œë“œ ì¤?..")
    encoder = instantiate(cfg.model)
    q_vec = encoder.encode([query])[0]       # (D,)

    # ?€?€ ? ì‚¬??ê³„ì‚° ?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€
    sims = cosine_similarity(q_vec, corpus)  # (N,)
    top_idx = np.argsort(sims)[::-1][:topk]

    # ?€?€ ê²°ê³¼ ì¶œë ¥ ?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€
    print(f"\n{'='*65}")
    print(f"  ?�ìœ„ {topk}ê°?? ì‚¬ ë¬¸ìž¥  (ëª¨ë�¸: {model_name})")
    print(f"{'='*65}")
    print(f"{'?œìœ„':>4}  {'? ì‚¬??:>6}  {'ì¹´í…Œê³ ë¦¬':<14}  ë¬¸ìž¥")
    print(f"{'-'*65}")
    for rank, idx in enumerate(top_idx, 1):
        sim   = sims[idx]
        label = labels[idx]
        text  = texts[idx]
        text_disp = text[:50] + ("?? if len(text) > 50 else "")
        print(f"{rank:>4}  {sim:>6.4f}  {label:<14}  {text_disp}")

    # ?€?€ ì¹´í…Œê³ ë¦¬ ë¶„í�¬ ?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€?€
    top_labels = [labels[i] for i in top_idx]
    from collections import Counter
    dist = Counter(top_labels)

    print(f"\n{'?€'*40}")
    print(f"  ?�ìœ„ {topk}ê°?ì¹´í…Œê³ ë¦¬ ë¶„í�¬")
    print(f"{'?€'*40}")
    for cat, cnt in sorted(dist.items(), key=lambda x: -x[1]):
        bar = "?? * cnt
        print(f"  {cat:<14} {cnt:>3}ê°? {bar}")

    print(f"\n[?´ì„�]")
    top_cat = dist.most_common(1)[0][0]
    if top_cat != "neutral":
        print(f"  ???�ìœ„ ?´ì›ƒ??ì£?ì¹´í…Œê³ ë¦¬: '{top_cat}'")
        print(f"     ì¿¼ë¦¬ê°€ ?´ë‹¹ ì¹´í…Œê³ ë¦¬ ?˜ë?ê³µê°„ ê·¼ì²˜??ë°°ì¹˜??)
    else:
        print(f"  ???�ìœ„ ?´ì›ƒ ?€ë¶€ë¶„ì�´ neutral")
        print(f"     ì¿¼ë¦¬ê°€ ?�ì˜¤/?? ¥ ?œí˜„ê³?ë©€ë¦?ë°°ì¹˜??)

    unique_cats = len(dist)
    if unique_cats >= 4:
        print(f"  ??{unique_cats}ê°?ì¹´í…Œê³ ë¦¬ê°€ ?¼ìž¬ ??ëª¨ë�¸?????œí˜„??ëª¨í˜¸?˜ê²Œ ?¸ì‹�")
    elif unique_cats <= 2:
        print(f"  ??{unique_cats}ê°?ì¹´í…Œê³ ë¦¬ë§??±ìž¥ ??ëª¨ë�¸?????œí˜„??ëª…í™•??êµ¬ë¶„")


if __name__ == "__main__":
    main()
